
#ifndef __construction_H__
#define __construction_H__


#include <stdbool.h>
/* ----------------------------------------------------------------------------------------------------------------------------  */
/* 图中顶点个数  */
/* A、B、C、D、E、F、G、H  */
#define VERTEXMAXSIZE 8 

#define NUL   0
#define TRUE  1
#define FALSE 0
/* ----------------------------------------------------------------------------------------------------------------------------  */



/* ----------------------------------------------------------------------------------------------------------------------------  */
/* 使用邻接表作为图的存储结构, 
 * 在邻接表中, 用一个一维数组存储图中每个顶点的信息, 
 * 同时为每个顶点建立一个单链表, 
 * 链表中的结点保存依附在该顶点上的边或弧的信息 
 */
/* 链表中的每个结点保存依附在该结点上的边或弧的信息  */
/* 图的存储结构                                      */
typedef struct node {
    int vertex;         /* 数据域, 在有向图中表示该弧所指向顶点（就是弧头）的位置, 在无向图中表示依附在该边上的另一个顶点的位置  */
    struct node *pNext; /* 指针域, 指向下一条依附在该顶点上的弧或边                                                              */
} Node;
typedef struct head {   /* 数组中的每个元素, 保存图中每个顶点相关信息  */
    char data;          /* 顶点数据域                                  */
    Node *first;        /* 在有向图中, 指向以该顶点为弧尾的第一条弧;
					     * 在无向图中, 指向依附在该顶点上的第一条边    */
} Head, *Graph;         /* 动态分配数组, 保存每个顶点相关信息          */


/* 图的函数原型  */
Graph create_graph( void );                    /* 根据图例创建对应的图                                         */
int first_vertex( Graph Gp, int pos );         /* 返回图中指定序号顶点的第一个邻接点                            */
int next_vertex( Graph Gp, int pos, int cur ); /* 返回图中指定序号结点的下一个邻接点                            */
void DFS( Graph Gp, int begin );               /* 从指定顶点出发, 深度优先遍历连通图                            */
void DFS_traverse( Graph Gp, int begin );      /* 从指定顶点出发, 深度优先遍历图; 可以是连通图也可以是非连通图    */
void BFS( Graph Gp, int begin );               /* 从指定顶点出发, 广度优先遍历连通图                            */
void BFS_traverse( Graph Gp, int begin );      /* 从指定顶点出发, 广度优先遍历图; 可以是连通图也可以是非连通图    */
/* ----------------------------------------------------------------------------------------------------------------------------  */



/* ----------------------------------------------------------------------------------------------------------------------------  */
/* 链式队列的存储结构  */
typedef struct NODE { 
    int data;           /* 数据域, 队列中的每个结点  */
    struct NODE *pNext; /* 指针域                    */
} NODE, *PNODE;
typedef struct Queue {  /* 始终指向队头与队尾  */
    PNODE front;        /* 队头指针            */
    PNODE rear;         /* 队尾指针            */
} QUEUE, *PQUEUE;


/* 链式队列的函数原型  */
PQUEUE create_queue( void );            /* 创建并建立一个空队列   */
bool is_empty( PQUEUE pS );             /* 判断队列是否为空       */
void en_queue( PQUEUE pS, int e );      /* 入队                  */
bool de_queue( PQUEUE pS, int *pData ); /* 出队                  */
void destroy_queue( PQUEUE pS );        /* 销毁队列              */
void traverse_queue( PQUEUE pS );       /* 遍历队列              */
/* ----------------------------------------------------------------------------------------------------------------------------  */


#endif
