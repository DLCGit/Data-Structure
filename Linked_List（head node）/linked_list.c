
/**************************************************************************************************************************
 以下为操作单链表的算法:
 链表以头指针为索引, 头指针指向头结点, 头结点指向首结点; 以此类推, 直到尾结点（ tail_N - 1 ）
 头结点中是不存放任何的数据, 只存放指向首结点的指针, 设置头节点的目的是为了方便对链表的增删改查操作,
 如果不设置头节点, 而是直接由头指针指向首节点, 这样在对头指针后的节点进行增删改查操作时会与其它结点进行操作时会有所不同,
 所以要作为一种特殊情况分析、处理
**************************************************************************************************************************/


/* --------------------------------------------------------------------------------------------------------------------  */
/* 相关接口  */
#include <stdio.h>
#include <stdlib.h>
/* --------------------------------------------------------------------------------------------------------------------  */


/* --------------------------------------------------------------------------------------------------------------------  */
/* 相关特殊宏常量  */
#define NUL   0
#define TRUE  1
#define FALSE 0
/* --------------------------------------------------------------------------------------------------------------------  */


/* --------------------------------------------------------------------------------------------------------------------  */
/* 链表结构  */
typedef struct Node {
	int data;           /* 数据域  */
	struct Node *pNext; /* 指针域  */
} NODE, *PNODE;
/* --------------------------------------------------------------------------------------------------------------------  */


/* --------------------------------------------------------------------------------------------------------------------  */
/* 函数原型  */
bool is_empty( PNODE pNode );                         /* 判断链表是否为空  */
PNODE create_list( void );                            /* 创建链表  */
bool insert_list( PNODE pHead, int pos, int val );    /* 在第 pos 个结点后面插入一个新结点, 该节点中的数据为 val  */
bool delete_list( PNODE pHead, int pos, int *pData ); /* 删除第 pos 个结点, 并将删除的结点保存到 pData 指针所指向的位置  */
void traverse_list( PNODE pHead );                    /* 打印链表结点  */
int length_list( PNODE pNode );                       /* 求链表长度  */
void sort_list( PNODE pHead );                        /* 排序链表（ 冒泡排序 ）  */
void clear_list( PNODE pHead );                       /* 清空链表, 即使链表只剩下头结点（ 头结点没有数据 ）  */
/* --------------------------------------------------------------------------------------------------------------------  */


/* --------------------------------------------------------------------------------------------------------------------  */
/* 主测试  */
int main( int argc, char **argv )
{
	/* 创建链表, 遍历输出  */
 	PNODE pHead = create_list();
	traverse_list( pHead );


	/* 求链表长度, 遍历输出  */
	int len = length_list( pHead );
	if ( !is_empty( pHead ) )
		printf( "链表长度为: %d \n", len );


	/* 向链表中插入结点，重新遍历输出  */
	if ( insert_list( pHead, 0, -1 ) ) /* 在头结点指针指向的第一个结点的位置前插入一个新结点 -1  */
		printf( "新结点插入成功, " );
	else
		printf( "新结点插入失败, " );
	traverse_list( pHead );            /* 打印新插入结点的新链表  */
	
	
	/* 从链表删除指定数据, 重新遍历输出  */
	int data_del = NUL;
	if ( delete_list( pHead, 2, &data_del ) ) /* 删除头结点指针指向的某个特定结点, 并将该结点存入 data_del  */
        printf( "指定结点删除成功, 删除的结点为: %d \n", data_del );
	else
		printf( "指定删除的结点在表中不存在, " );
	traverse_list( pHead );  /* 打印删除结点后的新链表  */
	
	
	/* 对链表排序, 重新遍历输出   */
	sort_list( pHead );      /* 将链表数据排序  */
	printf( "链表排序后为: " );
	traverse_list( pHead );  /* 打印排序后的链表  */

	/* 将链表清空, 重新遍历输出（ 无数据 ）  */
	clear_list( pHead );     /* 清除链表  */
	printf( "链表清除后为: " );
	traverse_list( pHead );  /* 打印清除数据后的链表  */
	
	return 0;
}
/* --------------------------------------------------------------------------------------------------------------------  */


/* --------------------------------------------------------------------------------------------------------------------  */
/* 判断链表是否为空  */
bool is_empty( PNODE pNode ) {
	if ( NULL == pNode->pNext )
		return TRUE;
	else
		return FALSE;
}
/* --------------------------------------------------------------------------------------------------------------------  */


/* --------------------------------------------------------------------------------------------------------------------  */
/* 创建链表  */
PNODE create_list( void ) {
	int val;
	PNODE pHead  = ( PNODE )malloc( sizeof( NODE ) ); /* 为头指针分配一块指向内存的空间  */
	PNODE p      = pHead; /* 将头指针存入 pCurr  */
	p->pNext     = NULL;  /* 初始头指针  */
	
	if ( NULL == pHead ) {
		printf( "为头指针分配内存失败! " );
		exit( -1 );
	}
	
	printf( "输入一个数（输入任意字母结束输入）: " );
	while ( TRUE == scanf( "%d", &val ) )
	{
		PNODE pNew = ( PNODE )malloc( sizeof( NODE ) );
		if ( NULL == pNew ) {
			printf( "为结点分配内存失败! " );
			exit( -1 );
		}
		pNew->data  = val;  /* 将新结点值存入 pNew  */
		p->pNext    = pNew; /* 将头指针指向头结点  */
		pNew->pNext = NULL; /* 为新的结点提前初始化分配的空间  */
		p           = pNew; /* 保存首结点值  */
		printf( "再输入一个数: " );
	}
	
	return pHead;
}
/* --------------------------------------------------------------------------------------------------------------------  */


/* --------------------------------------------------------------------------------------------------------------------  */
/* 在第 pos 个结点后面插入一个新结点, 该节点中的数据为 val  */
bool insert_list( PNODE pHead, int pos, int val ) {
    /* i为 0, p指向第 0 个结点（ 没有实际数据的头结点 ）
	 * i为 1, p指向第 1 个结点（ i为几, p 就指向第几个结点 ）
	 */
    int i   = 0;
	PNODE p = pHead;
	while ( NULL != p and pos > i ) {
	   p = p->pNext;
	   i++;
	}

	/* 当 pos 值大于链表长度, 会出现以下情况  */
	if ( pos < i or NULL == p )
	   return FALSE;


	PNODE pNew = ( PNODE )malloc( sizeof( NODE ) );
	if ( NULL == pNew ) {
	   printf( "为新结点分配内存失败! " );
	   exit( -1 );
	}
	pNew->data  = val;
	pNew->pNext = p->pNext;
	p->pNext    = pNew;

	return TRUE;
}
/* --------------------------------------------------------------------------------------------------------------------  */


/* --------------------------------------------------------------------------------------------------------------------  */
/* 删除第 pos 个结点, 并将删除的结点保存到 pData 指针所指向的位置  */
bool delete_list( PNODE pHead, int pos, int *pData ) {
	/* 如果下面两句分别改为 while ( NULL != p && pos > i )
	 * 与 if ( NULL == p || pos < i ), 则 p 最终指向第 pos 个结点
	 * 这样因为得不到第 pos 个结点前面的结点，因此无法将 pos 前后两个结点连结起来
	 */
	int i   = 0;
	PNODE p = pHead; /* p 最终指向第 pos 个结点前面的结点  */
	while ( NULL != p->pNext and pos - 1 > i ) {
	   	p = p->pNext;
	    i++;
	}

	/* 当 pos 值大于链表长度, 会出现以下情况   */
	if ( pos - 1 < i or NULL == p->pNext )
		return FALSE;

	PNODE q  = p->pNext;        /* 将指向首结点的指针存入 q  */
	*pData   = q->data;         /* 将删除的值保存到 pData  */
	p->pNext = p->pNext->pNext; /* 将首结点存入头结点内存  */
	free( q );
	q = NULL;
	
	return TRUE;
}
/* --------------------------------------------------------------------------------------------------------------------  */


/* --------------------------------------------------------------------------------------------------------------------  */
/* 打印链表结点  */
void traverse_list( PNODE pHead ) {
	PNODE pCurr = pHead->pNext;      /* 将头结点存入 pCurr  */
	printf( "链表中的数据为: " );
	while ( NULL != pCurr ) {        /* 非空则打印列表数据  */
		printf( "%d ", pCurr->data );
		pCurr = pCurr->pNext;        /* 将地址改成下一个  */
	}
	putchar( '\n' );
}
/* --------------------------------------------------------------------------------------------------------------------  */


/* --------------------------------------------------------------------------------------------------------------------  */
/* 求链表长度  */
int length_list( PNODE pNode ) {
	int count = 0;
	PNODE pCurr = pNode->pNext; /* 将头结点存入 pCurr  */
	while ( NULL != pCurr ) {
		count++;
		pCurr = pCurr->pNext;
	}

	return count;
}
/* --------------------------------------------------------------------------------------------------------------------  */


/* --------------------------------------------------------------------------------------------------------------------  */
/* 排序链表（ 冒泡排序 ）  */
void sort_list( PNODE pHead ) {
	for ( PNODE p = pHead->pNext; NULL != p; p = p->pNext ) {
		for ( PNODE q = p->pNext; NULL != q; q = q->pNext ) {
		   if ( p->data > q->data ) {
	 		   int tmp = p->data;
			   p->data = q->data;
			   q->data = tmp;
            }
		}
	}
}
/* --------------------------------------------------------------------------------------------------------------------  */


/* --------------------------------------------------------------------------------------------------------------------  */
/* 清空链表, 即使链表只剩下头结点（ 头结点没有数据 ）  */
void clear_list( PNODE pHead ) {
	PNODE pCurr = pHead->pNext; /* 将头结点存入 pCurr  */
	PNODE ptmp  = NULL;
	while( NULL != pCurr ) {
	   ptmp  = pCurr->pNext; /* 将首结点存入 ptmp  */
	   free( pCurr );        /* 清除头结点  */
	   pCurr = ptmp;         /* 将首结点存入 pCurr  */
	}
	pHead->pNext = NULL;     /* 初始化新的头结点  */
}
/* --------------------------------------------------------------------------------------------------------------------  */
